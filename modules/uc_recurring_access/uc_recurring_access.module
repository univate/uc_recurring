<?php
// $Id$

/**
 * @file
 * Provides a way to upgrade a recurring product.
 *
 * Initial module development sponsored by Marketing Results
 * http://www.marketing-results.com.au/
 *
 * Development
 *   Chris Hood http://univate.com.au
 */

/**
 * Implementation hook_perm()
 */
function uc_recurring_access_perm() {
  return array('administer recurring content');
}

/**
 * Implementation hook_menu()
 */
function uc_recurring_access_menu() {
  $items['admin/user/recurring_access'] = array(
    'type' => MENU_NORMAL_ITEM,
    'title' => 'Recurring Access',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_recurring_access_admin_settings'),
    'access arguments' => array('administer recurring content'),
    'file' => 'uc_recurring_access.admin.inc',
  );
  $items['node/%node/recurring_access'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => t('Recurring Access'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_recurring_access_node_form', 1),
    'access callback' => 'uc_recurring_access_content_type',
    'access arguments' => array(1),
    'file' => 'uc_recurring_access.page.inc',
  );

  $items['uc_recurring_access/product/autocomplete'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'uc_recurring_access_product_autocomplete',
    'access arguments' => array('administer recurring content'),
    'file' => 'uc_recurring_access.page.inc',
  );
  $items['uc_recurring_access/ahah/%'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'uc_recurring_access_ahah',
    'page arguments' => array(2),
    'access arguments' => array('administer recurring content'),
    'file' => 'uc_recurring_access.page.inc',
  );

  return $items;
}

/**
 * Check user has access to edit recurring access settings for this node.
 */
function uc_recurring_access_content_type($node) {
  $types = variable_get('uc_recurring_access_content_types',array());
  if (!empty($types[$node->type])) {
    return user_access('administer recurring content');
  }
  return FALSE;
}

/**
 * Implementation hook_theme()
 */
function uc_recurring_access_theme() {
  return array(
    'uc_recurring_access_items_items' => array(
      'arguments' => array('form' => NULL),
    ),
    'uc_recurring_time' => array(
      'arguments' => array('time' => NULL),
    ),
  );
}

/**
 * Implementation hook_nodeapi()
 */
function uc_recurring_access_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  global $user;

  // Do not limit access to admin users.
  if ($user->uid == 1 || user_access('administer recurring content')) {
    return;
  }

  $types = variable_get('uc_recurring_access_content_types',array());
  if (empty($types[$node->type])) {
    return;
  }

  // We only block access for the full node, teasers are still accessable.
  if ($op == 'view' && uc_recurring_access_node_has_rules($node)) {
    $teaser = $a3;
    $result = db_query("SELECT c.nid, c.access_type, c.id, u.time_applied, c.time_required
                        FROM {uc_recurring_access_content} c
                          LEFT JOIN {uc_recurring_access_user} u ON u.id=c.id AND c.access_type=u.access_type
                        WHERE c.nid = %d AND (u.uid = %d OR (c.access_type='role' && c.id = %d))
                        ORDER BY CAST(c.time_required - u.time_applied AS signed)",
                        $node->nid, $user->uid, DRUPAL_AUTHENTICATED_RID);

    $access = FALSE;
    while ($rule = db_fetch_object($result)) {
      $node->time_required = $rule->time_required;
      $node->time_applied = $rule->time_applied;
      if ($rule->access_type == 'role' && $rule->id == DRUPAL_AUTHENTICATED_RID) {
        $rule->time_applied = time() - $user->created;
      }
      if (($rule->time_applied - $rule->time_required) > 0) {
        $access = TRUE;
        break;
      }
    }
    $node->recurring_access = $access;
    if ($teaser == FALSE && $access == FALSE) {
      drupal_access_denied();
      exit;
    }
  }
}

/**
 * Implementation of hook_views_api().
 */
function uc_recurring_access_views_api() {
  return array(
    'api' => '2.0',
    'path' => drupal_get_path('module', 'uc_recurring_access') .'/views',
  );
}

/**
 * Create the access on a new recurring fee setup.
 *
 * @see uc_recurring_process_order
 */
function uc_recurring_access_uc_checkout_complete($order, $account) {
  $fees = uc_recurring_get_fees($order);
  foreach ($fees as $fee) {
    if ($fee->uid == 0) { // check for anonymous uid
      $fee->uid = $order->uid;
    }
    uc_recurring_access_recurring_renewal_completed($order, $fee);
  }
}

/**
 * Implements hook_recurring_renewal_completed()
 *
 * @see uc_recurring_renew()
 */
function uc_recurring_access_recurring_renewal_completed(&$order, &$fee) {
  global $user;
  $product = uc_recurring_product_fee_load($fee->pfid);
  $access = uc_recurring_access_user_load($fee->uid, 'node', $product->nid);
  if (empty($access)) {
    $access = new stdClass();
    $access->uid = $fee->uid;
    $access->created = time();
    $access->access_type = 'node';
    $access->id = $product->nid;
    $access->new = TRUE;
    $access->time_applied = 0;
    $access->time_owed = 0;
  }
  $interval = $fee->next_charge - time();
  $access->time_applied += min($interval, variable_get('uc_recurring_access_interval', '31536000'));
  $access->time_owed += $interval;
  uc_recurring_access_user_save($access);
  uc_order_comment_save($fee->order_id, $user->uid, t('Applied recurring access to product <a href="@product-url">@product</a>.', array('@product-url' => url('node/'. $product->nid), '@product' => $product->nid)));

  module_invoke_all('uc_recurring_access_apply', $fee, $product);
}

/**
 * Apply
 */
function uc_recurring_access_cron() {
  $time_now = time();
  $last_applied = variable_get('uc_recurring_access_interval_last_applied', 0);
  if ($last_applied == 0) {
    variable_set('uc_recurring_access_interval_last_applied', time());
  }
 
  $interval = variable_get('uc_recurring_access_interval', '31536000');
  if ($time_now - $last_applied >= $interval) {
    $interval = $time_now - $last_applied; 
    db_query("UPDATE {uc_recurring_access_user} SET time_applied = (time_applied + %d) WHERE time_applied < time_owed", $interval);
    // incase any user have been overcredited
    db_query("UPDATE {uc_recurring_access_user} set time_applied = time_owed WHERE time_applied > time_owed");
    variable_set('uc_recurring_access_interval_last_applied', time());
  }
}

/**
 * Save a access rule for a user.
 */
function uc_recurring_access_user_save($access) {
  if ($access->new) {
    drupal_write_record('uc_recurring_access_user', $access);
  }
  else {
    $key = array('uid', 'access_type', 'id');
    drupal_write_record('uc_recurring_access_user', $access, $key);
  }
}

/**
 * Load user access rules for this user.
 *
 * @param $uid
 *   User ID.
 * @param $type
 *   The access_type e.g. node, role.
 * @param $id
 *   The id of the access e.g nid, rid
 * @return
 *   The recurring access content rule object.
 */
function uc_recurring_access_user_load($uid, $type = NULL, $id = NULL) {
  if (!isset($type)) {
    $result = db_query('SELECT * FROM {uc_recurring_access_user} WHERE uid = %d', $uid);
  }
  else {
    $result = db_query("SELECT * FROM {uc_recurring_access_user} WHERE uid = %d AND access_type = '%s' AND id = %d", $uid, $type, $id);
  }

  $access = array();
  while ($rule = db_fetch_object($result)) {
    $access[] = $rule;
  }
  if (count($access) == 1) {
    return $access[0];
  }
  return $access;
}

/**
 *
 */
function uc_recurring_access_user_delete($uid, $type = NULL, $id = NULL) {
  if (!isset($type)) {
    db_query('DELETE FROM {uc_recurring_access_user} WHERE uid = %d', $uid);
  }
  else {
    db_query("DELETE FROM {uc_recurring_access_user} WHERE uid = %d AND access_type = '%s' AND id = %d", $uid, $type, $id);
  }
  return SAVED_DELETED;
}

/**
 * Save node access rule.
 *
 * @param $access
 *   The recurring node access object.
 */
function uc_recurring_access_node_save($access) {
  drupal_write_record('uc_recurring_access_content', $access);
}

/**
 * Load node access rule.
 *
 * @param $nid
 *   Node ID.
 */
function uc_recurring_access_node_load($nid) {
  $result = db_query("SELECT * FROM {uc_recurring_access_content} WHERE nid = %d", $nid);
  $node_access = array();
  while ($access = db_fetch_object($result)) {
    $node_access[] = $access;
  }
  return $node_access;
}

/**
 * Delete node access rule.
 */
function uc_recurring_access_node_delete($nid, $access_type, $id) {
  db_query("DELETE FROM {uc_recurring_access_content}
            WHERE nid = %d AND access_type = '%s' AND id = %d",
            $nid, $access_type, $id);

  return SAVED_DELETED;
}

/**
 * If a node has no rules then we grant access to everyone.
 */
function uc_recurring_access_node_has_rules($node) {
  $count = db_result(db_query("SELECT count(*) FROM {uc_recurring_access_content} WHERE nid = %d", $node->nid));
  return ($count > 0);
}

/**
 * Load the access rules.
 */
function _uc_recurring_access_rules() {
  $access_types = array('node' => t('Subscription Product'));
  drupal_alter('uc_recurring_access_types', $access_types);
  return $access_types;
}


/**
 * Implementation of hook_user().
 *
 * Add access rules to users account page, so admins can alter.
 */
function uc_recurring_access_user($type, &$edit, &$account, $category = NULL) {
  switch ($type) {
    case 'delete':
      return uc_recurring_access_user_delete($account);
    case 'form':
      return uc_recurring_access_user_form($edit, $account, $category);
    case 'submit':
      return uc_recurring_access_user_submit($edit, $account, $category);
    case 'validate':
      return uc_recurring_access_user_validate($edit, $account, $category);
    case 'view':
      //return uc_recurring_access_user_view($edit, $account);
  }
}

/**
 *
 */
function uc_recurring_access_user_form($edit, $account, $category) {
  if (!(user_access('administer users') && user_access('administer recurring content')) || $category != 'account') {
    return;
  }

  $form['uc_recurring_access'] = array(
    '#type' => 'fieldset',
    '#title' => t('Recurring Access'),
    '#description' => t('Here you can view what recurring access permission this user has purchased, as well as edit the access on a users account.'),
  );
  
  $form['uc_recurring_access']['recurring_access']['#theme'] = 'uc_recurring_access_items_items';
  $form['uc_recurring_access']['recurring_access']['#tree'] = TRUE;

  $access = uc_recurring_access_user_load($account->uid);
  if (!is_array($access)) {
    $access = array($access);
  }
  $rule_types = _uc_recurring_access_rules();
  foreach($access as $access_rule) {
    switch ($access_rule->access_type) {
      case 'node':
        $product = node_load($access_rule->id);
        $value = l($product->title, 'nid/'. $access_rule->id);
        break;
      case 'role':
        static $roles;
        if (!isset($roles)) {
          $roles = user_roles(TRUE);
        }
        $value = $roles[$access_rule->id];
    }
    $form['uc_recurring_access']['recurring_access'][$access_rule->access_type .'-'. $access_rule->id] = array(
      'access_type' => array(
        '#value' => $rule_types[$access_rule->access_type],
      ),
      'match' => array(
        '#value' => $value,
      ),
      'delete' => array(
        '#type' => 'checkbox',
      ),
      'time_applied' => array(
        '#type' => 'textfield',
        '#size' => 20,
        '#default_value' => theme('uc_recurring_time', $access_rule->time_applied),
      ),
      'time_required' => array(
        '#type' => 'textfield',
        '#size' => 20,
        '#default_value' => theme('uc_recurring_time', $access_rule->time_owed),
      ),
    );
  }


  // add new rule form
  drupal_add_js('misc/autocomplete.js');
  $rule_types = _uc_recurring_access_rules();
  $form['uc_recurring_access']['recurring_access']['new']['access_type'] = array(
    '#type' => 'select',
    '#options' => array('' => 'Add recurring access rule for ...') + $rule_types,
    '#ahah' => array(
      'event' => 'change',
      'path' => 'uc_recurring_access/ahah/access_type',
      'wrapper' => 'recurring-access-type',
      'method' => 'replace',
      'effect' => 'fade',
      'progress' => array(
      ),
    ),
  );
  $form['uc_recurring_access']['recurring_access']['new']['match'] = array(
    '#value' => '<div id="recurring-access-type"></div>'
  );
  $form['uc_recurring_access']['recurring_access']['new']['time_applied'] = array(
    '#type' => 'textfield',
    '#description' => t('Enter a PHP time, e.g. 1 week'),
    '#size' => 20,
  );
  $form['uc_recurring_access']['recurring_access']['new']['time_required'] = array(
    '#type' => 'textfield',
    '#description' => t('Enter a PHP time, e.g. 1 week'),
    '#size' => 20,
  );
  return $form;
}

/**
 *
 */
function uc_recurring_access_user_submit($edit, $account, $category) {
  if (!(user_access('administer users') && user_access('administer recurring content')) || $category != 'account') {
    return;
  }

  $access = uc_recurring_access_user_load($account->uid);
  foreach ($edit['recurring_access'] as $id => $rule) {
    if ($id == 'new' && !empty($edit['match'])) {
      $access = new stdClass();
      $access->uid = $account->uid;
      $access->created = time();
      $access->access_type = $rule['access_type'];
      $access->id = $edit['match'];
      $access->new = TRUE;
      $access->time_applied = strtotime('+'. $rule['time_applied']) - time();
      $access->time_owed = strtotime('+'. $rule['time_required']) - time();
      uc_recurring_access_user_save($access);
    }
    else {
      list($type, $id) = split('-', $id);
      if (!empty($rule['delete'])) {
        uc_recurring_access_user_delete($account->uid, $type, $id);
      }
      else {
        $access = new stdClass();
        $access->uid = $account->uid;
        $access->created = time();
        $access->access_type = $type;
        $access->id = $id;
        $access->time_applied = strtotime('+'. $rule['time_applied']) - time();
        $access->time_owed = strtotime('+'. $rule['time_required']) - time();
        uc_recurring_access_user_save($access);
      }  
    }
  }
}

/**
 *
 */
function uc_recurring_access_user_validate($edit, $account, $category) {
  if (!(user_access('administer users') && user_access('administer recurring content')) || $category != 'account') {
    return;
  }
  $message = t('Incorrect format for time value');
  foreach ($edit['recurring_access'] as $id => $rule) {
    if ($id != 'new') {
      $time_applied = strtotime('+'. $rule['time_applied']);
      if ($time_applied < 0) {
        form_set_error('recurring_access', $message);
      }
      $time_required = strtotime('+'. $rule['time_required']);
      if ($time_required <= 0) {
        form_set_error('recurring_access', $message);
      }
      if ($time_applied > $time_required) {
        form_set_error('recurring_access', t('The time applied to an account cannot be larger then the purchased time.'));
      }
    }
  }
}

/**
 * Theme the node recurring access rules in a table.
 */
function theme_uc_recurring_access_items_items($form) {
  $header = array(t('Access type'), t('ID / Object'), t('Purchased time'), t('Delete'));
  $rows = array();
  foreach (element_children($form) as $key) {
    $row = array();
    $row[] = drupal_render($form[$key]['access_type']);
    $row[] = drupal_render($form[$key]['match']);
    if (!empty($form[$key]['time_applied'])) {
      $row[] = drupal_render($form[$key]['time_applied']);
      $header = array(t('Access type'), t('ID / Object'), t('Time applied'), t('Purchased time'), t('Delete'));
    }
    $row[] = drupal_render($form[$key]['time_required']);
    $row[] = drupal_render($form[$key]['delete']);
    $rows[] = $row;
  }
  $output = theme('table', $header, $rows);
  $output .= drupal_render($form);
  return $output;
}

/**
 * Takes a time in seconds and converts to something more readable.
 * e.g. 2 weeks 4 days
 */
function theme_uc_recurring_time($time) {
  $periods = array(
    'week' => 604800,
    'day' => 86400,
    'hour' => 3600,
    'min' => 60,
  );
  $str = '';
  foreach ($periods as $suffix => $t) {
    if ($time >= $t) {
      $unit = intval($time / $t);
      if ($unit <= 0) continue;
      $time = $time % $t;
      $str .= $unit .' '. $suffix .' ';
    }
  }
  return $str;
}
